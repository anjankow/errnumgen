// Code generated by errnumgen. DO NOT EDIT.
// Package {{ .package_name }} defines error numbers that are uniquely assigned
// to each error in the source code.
package errnums

import (
	"errors"
	"fmt"
	"strconv"
	"strings"
)

// Err is wraps the original error adding its number
type Err struct {
	Num ErrNum
	Err error
}

// Error returns a human readable print of this error prefixed with the error codes
// of this and following errors
func (e Err) Error() string {
	var numsTrace []string
	var next error = &e
	for {
		if next == nil {
			break
		}

		var errPtr *Err
		switch err := next.(type) {
		case *Err:
			errPtr = err
		case Err:
			errPtr = &err
		default:
			// Unwrap
			next = errors.Unwrap(next)
			continue
		}

		numsTrace = append(numsTrace, strconv.Itoa(int(errPtr.Num)))

		next = errPtr.Err
	}

	return fmt.Sprintf("(%s) %v", strings.Join(numsTrace, "-"), e.Err)
}

func (e Err) Format(f fmt.State, verb rune) {
	switch verb {
	case 'v':
		if f.Flag('+') {
			fmt.Fprintf(f, "code=%d err=%q %+v", e.Num, e.Err, e.Err)
			return
		}
		fallthrough
	case 's':
		fmt.Fprint(f, e.Error())
	}
}

func New(num ErrNum, err error) error {
	return Err{
		Num: num,
		Err: err,
	}
}

type ErrNum int

{{ .const_declarations }}
