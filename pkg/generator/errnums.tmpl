// Code generated by errnumgen. DO NOT EDIT.
// Package {{.package_name}} defines error numbers that are uniquely assigned
// to each error in the source code.
package {{.package_name}}

import (
	"errors"
	"fmt"
	"runtime"
	"strconv"
	"strings"
)

// ErrWrapper wraps the original error adding its number and frame
type ErrWrapper struct {
	Num   ErrNum
	Err   error
	Frame frame
}

type frame struct {
	File string
	Line int
}

// New wraps the original error with the ErrWrapper
func New(num ErrNum, err error) error {
	var fr frame
	_, file, line, ok := runtime.Caller(1)
	if ok {
		fr = frame{
			File: file,
			Line: line,
		}
	}

	return ErrWrapper{
		Num:   num,
		Err:   err,
		Frame: fr,
	}
}

func (w ErrWrapper) Error() string {
	return w.Err.Error()
}

func (e ErrWrapper) Unwrap() error {
	return e.Err
}

func (e ErrWrapper) Format(f fmt.State, verb rune) {
	switch verb {
	case 'v':
		if f.Flag('+') {
			fmt.Fprintf(f, "%s:%d %v", e.Frame.File, e.Frame.Line, e.Err)
			next := errors.Unwrap(e.Err)
			if next != nil {
				fmt.Fprintf(f, "\n  %+v", next)
			}
			return
		}
		fallthrough
	case 's':
		fmt.Fprint(f, e.Error())
	}
}

func Code(err error) string {
	codes := make([]string, 0)
	errPtr := err
	for {
		if errPtr == nil {
			break
		}

		var target ErrWrapper
		if errors.As(errPtr, &target) {
			codes = append(codes, target.Num.String())
			errPtr = target.Err
			continue
		}
		errPtr = errors.Unwrap(errPtr)
	}

	return strings.Join(codes, "-")
}

type ErrNum int

func (n ErrNum) String() string {
	return strconv.Itoa(int(n))
}

{{ .const_declarations }}
